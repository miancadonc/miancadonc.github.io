---
layout: post
title:      "Learning to Love the Bug"
date:       2021-04-30 19:04:38 +0000
permalink:  learning_to_love_the_bug
---


In comparison with the javascript project, the react-redux project may seem intimidating. There’s just a lot more that you have to do and be aware of. There’s reducers, state, the store, dispatch etc. Components themselves might not be that difficult, since in javascript programmatically creating presentational bits was really important, but combining them with props correctly can be a hassle when you’re not as familiar with redux.

All that said, even though working on this project made me feel like I ran across bugs that were stickier and more frequent, as a rule React's emphasis on file structure and convention meant that these bugs, as a rule, only broke one thing at a time. And, even better, once fixed they tended to stay very fixed relative to javascript bugs. There were a number of times that I screwed up previously finished functions during the Js project by tinkering with another related part of the code. As a result, I now have an appreciation for the concept of pure functions, and while I’m still learning how to implement them, I try to where I can. Additionally, the inbuilt separated structure of React conventions meant that I also knew where to look to fix these bugs much more frequently. With Js, I had to look at all the places where my data was manipulated or passed down inside one large cumbersome file. With React, I just had to look in a few short self contained folders.

In that context, bugs can actually be kind of helpful. Of course, on one level, bugs are bugs. They’re frustrating no matter what conventions or technologies you’re working with. Still, in React, one bug in particular pushed me to realize what the convention of actions was doing. I had been simply copying down conventions when it came to actions in redux and thunk because I didn’t quite understand why the fetch requests had to go in a separate folder. I understood the store at this point, as well as the reducers I was using, but that understanding was outside of the context of thunk and asynchronous redux altogether. I did have some vague notion that actions came before the reducer, since they ultimately sent off that action objects that made their way into the reducers, but I’d become accustomed to sending off dispatches in the middle of components, without mapping them to props systematically. 

As a result of all this, I encountered my bug and had to flail around wildly in the dark for a while in order to fix it. I was able to fire off a fetch blindly, without fully realizing why different dispatches were in different places within the action functions I was creating, and could see in the dev tools that something was being returned from the api and being put into the store. The components, however, were not re-rendering visually. They were in fact receiving new props from the store, so I thought they must not be able to use the props correctly, and I spent some time trying to force them to render data they didn’t actually have. My problem was simply that I’d created a handleLoading method and the conditional inside only looked at the props to see if loading was true; I figured since this was set in the action, it just worked like a switch; while loading, don’t render anything. Once done, load the child component using the store. The problem though, is that I had set loading to default to false. This crashed my app since the components didn’t have access to props yet but were still trying to load. Once I traced to actions being sent to the reducer, however, this became pretty obvious and suggested a couple solutions. I ended up simply also making the handleLoading method’s conditional statement based on the presence of data, since that seemed pretty crucial in order to avoid crashing.
All in all, the other bugs that I encountered were mostly like this. React, alongside redux, just really fortified my conceptual understanding of the different concerns that go into a Js project like this. Each bug was really annoying while debugging, but they all helped me to understand through fixing them how the structure of the application worked. I believe in a mix of learning through direct conceptual comprehension work and also simply through tinkering and running into problems and solving them as they come along. This project, as well as the React docs and resources available online, ended up synergizing pretty well with this dual learning approach of mine. Seeing each bug as an opportunity to reinforce what I already know conceptually is a much easier and nicer way of looking at bugs than what I was capable of when it came to problem solving in Js. 

A final little note though, is that the complete control afforded by vanilla Js in that project did leave me with a very good roadmap of my project in my own head, even if it was a headache to debug and even if those headaches didn’t feel like they productively added to my learning. I think grappling with the most basic tools and primitively solving problems on your own that other people have solved already, and much better, is also a valuable way to come into contact with such problems head on. It’s helped me learn to appreciate the work of other people who came into contact with those same problems first.


