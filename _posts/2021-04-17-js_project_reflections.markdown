---
layout: post
title:      "JS Project Reflections"
date:       2021-04-17 06:45:02 +0000
permalink:  js_project_reflections
---


This will definitely be a bit of a rambling post. Sometimes, it’s nice to take stock of several smaller points of interest when reflecting on a project. Each specific point can often be examined very closely and thoroughly, and that approach certainly has its merits; still, taking a broad view can keep some of the things you’ve learned and decisions you’ve made in perspective. It’s important, after all, when using multiple technologies, to take stock of how they collaborate.

As a very simple example, during this Javascript project, I learned a few things about how I approach JS and CSS together. I realized that my normal instincts are not very programmatic, when faced with the task of changing items on a page or rendering new ones. I always have a long list of declared variables at the top of my index.js that house various nodes that I know I’m going to use again and again. There’s maybe not much wrong with this, but it of course doesn’t work when rendering collections of objects that need to be responsive and change programmatically. Selecting each object and rendering it and styling it is just not feasible. It’s not very interesting probably to point out that classes that can be styled and JS’s classList method both exist, but it’s just really helpful to have to use them both in practice to keep objects uniform and clear. 

Reinforcing those by using a js class for my objects (even though they were already ruby objects in my api), as well as by encapsulating the rendering work in a function that only rendered one at a time, but that could be called on a whole collection programmatically, helped me keep myself sane. I realized this as I stumbled my way through the project, writing each function as I needed it to do some specific work. I managed to write almost the exact same lines of code for very similar object rendering tasks in different situations before I finally got annoyed and extracted it away. It’s easy to get too focused on the specific task you want to accomplish next, and if you don’t have a ton of experience with the conventions of the tech you’re working with, you might stumble into some annoying situations. That’s not always a bad thing though, if that means you’ve learned what problems you’re going to run into during your next project! 

Running into obstacles and then learning why conventions exist in the first place is certainly a welcome lesson. More broadly, running into the same problems as other people have before you and devising your own solution before searching more deeply and comparing yours to others allows you to find gaps in your knowledge and to know more specifically where there is more for you to learn. So, to switch gears for a moment: I also ran into a little bit of trouble with fetch requests to my api. 

Specifically, the fetch requests that were supposed to perform create and update actions. In may particular case, the JS objects I was working with lined up perfectly in terms of properties with the Ruby objects I was using to render my api, so the body of my fetch requests was basically just the object to be created or updated. Since these objects always belong to another set of objects though, I needed access to the appropriate owner objects in my controllers. I ended up just creating dummy objects from my JS class that I didn’t save anywhere, and simply storing the id of the owner object in the regular id key. Obviously this is a little bit weird. It probably means the code is a little less maintainable, since if I did this in an environment where others might read the code they might make wrong assumptions even with proper comments. Two alternative solutions have sprung to mind since: I could simply include both objects in the body of the fetch request, or I could perhaps change the first objects’ constructor such that I have a key for storing the owner object id. Cool! Either way though, I can probably expect to see a lot of fetch requests of this type written by other coders in the future, and I’m pretty happy to know that this tiny little problem is a chance for growth, even if only a little bit.

If there’s a through-line to this post, I think it’s a simple reflection of mine on the difference between the rails project and this one, at least as far as I see it. Now, I don’t know if there’s as much of an emphasis on convention within JS circles as in rails ones, but I do know that the modules and projects that dealt with rails definitely explained conventions and tidiness in that system much more than in JS. I think both teaching methods are pretty valid though. With rails, I had a solid foundation for writing tidy, maintainable code. With JS, my main file is an absolute mess. But honestly, that just makes me want to learn more about JS. I wanna find my own ways of keeping things easy for myself, and also see what other people have been doing. And this way, I might find a few more interesting niches of knowledge to delve into.
